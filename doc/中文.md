## Contentful Config

Contentful是一个 Headless CMS API 提供商，你可以在 Contentful 的可视化后台撰写文章，无需学习 Markdown 语法(虽然这已经很简单了...)，不论如何，在你开始设置之前，我假设你已经注册好了Contentful。

1. 创建你的空间

完成注册账号流程的你应该已经有了一个空间(Space)，点击你的空间名称进入空间，此时浏览器地址栏应该显示的是一下URL

```url
https://app.contentful.com/spaces/<Your_space_id>/home
```

2. 创建模型

单击左上角的 创建模型(Create model) 随意填写你的 名称(Name) 和 API标识符(Api Identifier)，记下标识符后点击创建。

3. 创建字段

**！！此步骤非常重要！！**，单击 添加字段(Add field) 并按照下表所示添加全部字段
| 字段类型(FieldType) | 字段ID(FieldID) | 选项(Options) | 是否必须 | 用途 |
| ------- | ------- | ------- | ------- | ------- |
| Text | blogTitle | 勾选 This field represents the Entry title 以及 Required field | 必须 | 博客标题 |
| Text | blogSlug | 勾选 Required field；以及 Unique field；鼠标滚轮滚动到 Appearance 区域选择 Slug 模式；Generate slug from 下拉菜单选择你刚才填写的 blogTitle | 必须 | 文章URL |
| Text | blogDescription | 勾选 Required field，你可以下拉填写默认值(Default value)| 必须 | 文章描述 |
| Rich text | blogContent | 勾选 Required field | 必须 | 文章内容 |
| Date & Time | publishedTime | 勾选 Required field(如果添加的话) | 可选 | 自定义发布日期 |
| Boolean | isPinned | 无 | 可选 | 后续可能会开发的文章置顶功能 |

**创建完成后记得保存(Save)！**

4. 获取 Contentful API 密钥

单击右上角的 齿轮图标(Setting) 选择 API Keys -> Add API Key -> 随意填写API名称
进入API密钥页面，点击复制 **Content Delivery API - access token** 注意，此处必须选额 DeliveryAPI ，否则其他人可能会访问到你的草稿内容，甚至是修改你账号的内容！

5. 填写 .env 文件

- VITE_CONTENTFUL_BLOG_MODEL 对应你刚才创建的 模型API标识符
- VITE_CONTENTFUL_SPACE_ID 会与你的 Token 一同出现
- VITE_CONTENTFUL_DELIVERY_TOKEN 你刚才获取的Token，再次提醒，是只读Token！
- VITE_CONTENTFUL_BLOG_ORDER_TYPE 如果你添加了 publishedTime 字段，请填写 publishedTime 否则请填写 createdAt

## 开始构建项目

1. 安装 [node.js](https://nodejs.org/zh-cn) 和 [git](https://git-scm.com/downloads)

2. 克隆或下载仓库源代码到本地

```bash
git clone https://github.com/KumaKorin/react-homepage.git
```

3. 下载依赖

```bash
npm install
```

4. 开始构建

```bash
npm run build
```

5. 完成！

或者，你可以fork此仓库，在修改env后使用github action构建

如果你担心你的 contentful API 配额不够，可考虑使用 cloudflare worker 作为缓存代理，worker 代码参考：

```javascript
/**
 * Configuration
 * 你可以在这里调整默认的缓存时间
 */
const CONFIG = {
    CONTENTFUL_HOST: 'cdn.contentful.com',
    CACHE_TTL: 60 * 60 * 12, // 默认缓存 12 小时 (单位秒)
    // 如果你需要强制覆盖 Contentful 返回的 Cache-Control，可以在这里开启
    FORCE_CACHE_TTL: true
}

export default {
    async fetch(request, env, ctx) {
        if (request.method === 'OPTIONS') {
            return handleOptions(request)
        }

        const url = new URL(request.url)
        url.hostname = CONFIG.CONTENTFUL_HOST

        const proxyRequest = new Request(url.toString(), {
            method: request.method,
            headers: request.headers,
            redirect: 'follow'
        })
        const cache = caches.default
        let response = await cache.match(proxyRequest)

        if (response) {
            const newHeaders = new Headers(response.headers)
            newHeaders.set('X-Worker-Cache', 'HIT')
            setCorsHeaders(newHeaders)

            return new Response(response.body, {
                status: response.status,
                statusText: response.statusText,
                headers: newHeaders
            })
        }

        try {
            response = await fetch(proxyRequest)

            if (!response.ok) {
                return response
            }

            const responseToCache = response.clone()
            const headersToCache = new Headers(responseToCache.headers)

            if (CONFIG.FORCE_CACHE_TTL) {
                headersToCache.set('Cache-Control', `public, max-age=${CONFIG.CACHE_TTL}, s-maxage=${CONFIG.CACHE_TTL}`)
            }

            const cacheResponse = new Response(responseToCache.body, {
                status: responseToCache.status,
                statusText: responseToCache.statusText,
                headers: headersToCache
            })

            ctx.waitUntil(cache.put(proxyRequest, cacheResponse))

            const responseHeaders = new Headers(response.headers)
            responseHeaders.set('X-Worker-Cache', 'MISS')
            setCorsHeaders(responseHeaders)

            return new Response(response.body, {
                status: response.status,
                statusText: response.statusText,
                headers: responseHeaders
            })
        } catch (e) {
            return new Response(JSON.stringify({ error: e.message }), {
                status: 500,
                headers: { 'Content-Type': 'application/json' }
            })
        }
    }
}

function handleOptions(request) {
    const headers = request.headers
    if (
        headers.get('Origin') !== null &&
        headers.get('Access-Control-Request-Method') !== null &&
        headers.get('Access-Control-Request-Headers') !== null
    ) {
        const respHeaders = new Headers({
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, HEAD, POST, OPTIONS',
            'Access-Control-Max-Age': '86400',
            'Access-Control-Allow-Headers': request.headers.get('Access-Control-Request-Headers')
        })
        return new Response(null, {
            headers: respHeaders
        })
    } else {
        return new Response(null, {
            headers: {
                Allow: 'GET, HEAD, POST, OPTIONS'
            }
        })
    }
}

function setCorsHeaders(headers) {
    headers.set('Access-Control-Allow-Origin', '*')
    headers.set('Access-Control-Allow-Methods', 'GET, HEAD, POST, OPTIONS')
    headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization')
}
```
